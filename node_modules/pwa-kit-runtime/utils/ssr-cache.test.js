"use strict";

var _ssrCache = require("./ssr-cache");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
const localRemoteTestCases = [true, false];
localRemoteTestCases.forEach(useLocalCache => {
  const name = `${useLocalCache ? 'Local' : 'Remote'} noop PersistentCache`;
  describe(name, () => {
    const testCache = new _ssrCache.PersistentCache({
      useLocalCache,
      bucket: 'TestBucket',
      s3Endpoint: 'http://localhost:4568',
      accessKeyId: 'S3RVER',
      secretAccessKey: 'S3RVER',
      sendMetric: () => {}
    });
    const key = 'key';
    const namespace = 'namespace';
    const buf = Buffer.alloc(8);
    for (let i = 0; i <= 8; i++) {
      buf[i] = i;
    }
    const expiration = Date.now() + 10000;
    test('get', () => {
      testCache.get({
        key,
        namespace
      }).then(result => {
        expect(result.data).toBeUndefined();
        expect(result.metadata).toBeUndefined();
        expect(result.found).toBe(false);
        expect(result.key).toEqual(key);
        expect(result.namespace).toEqual(namespace);
      });
    });
    test('put', () => {
      testCache.put({
        key,
        namespace,
        data: buf,
        expiration
      }).then(() => testCache.get({
        key,
        namespace
      })).then(result => {
        expect(result.data).toBeUndefined();
        expect(result.metadata).toBeUndefined();
        expect(result.found).toBe(false);
        expect(result.key).toEqual(key);
        expect(result.namespace).toEqual(namespace);
      });
    });
    test('delete', /*#__PURE__*/_asyncToGenerator(function* () {
      yield expect(testCache.delete({
        key,
        namespace
      })).resolves.not.toThrow();
    }));
  });
});